<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Typified.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hoot-runtime</a> &gt; <a href="index.source.html" class="el_package">Hoot.Runtime.Behaviors</a> &gt; <span class="el_source">Typified.java</span></div><h1>Typified.java</h1><pre class="source lang-java linenums">package Hoot.Runtime.Behaviors;

import java.util.*;
import java.lang.reflect.*;

import Hoot.Runtime.Faces.Named;
import Hoot.Runtime.Names.TypeName;
import Hoot.Runtime.Values.Variable;
import static Hoot.Runtime.Functions.Utils.*;
import static Hoot.Runtime.Behaviors.HootRegistry.*;
import Hoot.Runtime.Faces.Logging;
import Hoot.Runtime.Faces.Valued;
import static Hoot.Runtime.Names.Primitive.isStatic;

/**
 * An essential type description.
 * &lt;h4&gt;Typified Responsibilities:&lt;/h4&gt;
 * &lt;ul&gt;
 * &lt;li&gt;knows its metaClass&lt;/li&gt;
 * &lt;li&gt;knows its immediate superclass&lt;/li&gt;
 * &lt;li&gt;knows its corresponding primitive Java class&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author nik &lt;nikboyd@sonic.net&gt;
 * @see &quot;Copyright 2010,2021 Nikolas S Boyd.&quot;
 * @see &quot;Permission is granted to copy this work provided this copyright statement is retained in all copies.&quot;
 */
public interface Typified extends Valued.Metatype, Named, Logging {

    /**
     * Meta-type base type.
     */
    public static interface Metatype extends Typified { } // Metatype

    public Typified $class();
    public Typified superclass();

<span class="nc" id="L38">    default Class&lt;?&gt; outerClass() { return typeMirror().outerClass(); }</span>
<span class="fc" id="L39">    default void reportRegistration() { whisper(&quot;registered &quot; + primitiveClass().getCanonicalName()); }</span>

<span class="fc" id="L41">    default Mirror typeMirror() { return Mirror.forType(this); }</span>
<span class="fc" id="L42">    default String packageName() { return typeMirror().primitiveClass().getPackage().getName(); }</span>
<span class="nc" id="L43">    default TypeName typeResolver() { return TypeName.fromOther(this); }</span>

<span class="nc" id="L45">    default boolean isEmpty() { return typeMirror().isEmpty(); }</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">    default boolean hasMetaface() { return $class() != null; }</span>
<span class="nc" id="L47">    default boolean isReflective() { return false; }</span>

<span class="nc bnc" id="L49" title="All 4 branches missed.">    default boolean isRoot() { return !isEmpty() &amp;&amp; typeResolver().isRootType(); }</span>
<span class="nc" id="L50">    default boolean isElementaryType() { return typeResolver().isElementaryType(); }</span>
    default boolean isEraseableType() {
<span class="nc bnc" id="L52" title="All 4 branches missed.">        return (isRoot()) || typeResolver().isEraseableType() ||</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">            this.inheritsFrom(Mirror.forClass(RootClass())); }</span>

<span class="nc" id="L55">    default boolean overridenBy(Signed s)  { return typeMirror().overridenBy(s); }</span>

<span class="nc" id="L57">    default Signed getSigned(Signed s) { return getSigned(s.matchSignature()); }</span>
<span class="nc" id="L58">    default Signed getSigned(String s) { return typeMirror().getSigned(s); }</span>
<span class="nc" id="L59">    default String matchSignatures(Signed s) { return typeMirror().matchSignatures(s); }</span>

<span class="nc" id="L61">    default boolean resolves(Named reference) { return false; }</span>
<span class="nc" id="L62">    default Class&lt;?&gt; resolveType(Named reference) { return null; }</span>
<span class="nc" id="L63">    default Variable localNamed(String symbol) { return null; }</span>
<span class="nc" id="L64">    default String resolveTypeName(Named reference) { return Empty; }</span>
<span class="fc" id="L65">    public static List&lt;String&gt; names(List&lt;Typified&gt; types) { return map(types, type -&gt; type.name().toString()); }</span>

<span class="nc bnc" id="L67" title="All 4 branches missed.">    default boolean inheritsFrom(Typified candidate) { return hasAny(candidate) &amp;&amp; fullInheritance().contains(candidate); }</span>
<span class="nc" id="L68">    default List&lt;Typified&gt; simpleHeritage() { return emptyList(Typified.class); }</span>
<span class="nc" id="L69">    default List&lt;Typified&gt; typeHeritage() { return emptyList(Typified.class); }</span>
    default List&lt;Typified&gt; fullInheritance() {
<span class="nc" id="L71">        ArrayList&lt;Typified&gt; results = emptyList(Typified.class);</span>
<span class="nc" id="L72">        results.addAll(simpleHeritage());</span>
<span class="nc" id="L73">        results.addAll(typeHeritage());</span>
<span class="nc" id="L74">        return results; }</span>

    default Map&lt;String, Field&gt; instanceFields() {
<span class="nc" id="L77">        HashMap&lt;String, Field&gt; results = emptyMap(Field.class);</span>
<span class="nc" id="L78">        wrap(primitiveClass().getDeclaredFields()).forEach(f -&gt; {</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (!isStatic(f)) results.put(f.getName(), f);</span>
<span class="nc" id="L80">        });</span>
<span class="nc" id="L81">        return results; }</span>

    default Map&lt;String, Field&gt; staticFields() {
<span class="nc" id="L84">        HashMap&lt;String, Field&gt; results = emptyMap(Field.class);</span>
<span class="nc" id="L85">        wrap(primitiveClass().getDeclaredFields()).forEach(f -&gt; {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">            if (isStatic(f)) results.put(f.getName(), f);</span>
<span class="nc" id="L87">        });</span>
<span class="nc" id="L88">        return results; }</span>

} // Typified
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>