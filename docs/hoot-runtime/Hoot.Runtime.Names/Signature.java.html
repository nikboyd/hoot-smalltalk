<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Signature.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hoot-runtime</a> &gt; <a href="index.source.html" class="el_package">Hoot.Runtime.Names</a> &gt; <span class="el_source">Signature.java</span></div><h1>Signature.java</h1><pre class="source lang-java linenums">package Hoot.Runtime.Names;

import java.util.*;
import java.lang.reflect.Type;
import java.lang.reflect.Method;

import Hoot.Runtime.Behaviors.*;
import static Hoot.Runtime.Functions.Utils.*;
import static Hoot.Runtime.Names.Keyword.Object;
import static Hoot.Runtime.Names.Keyword.Colon;

/**
 * A method signature.
 *
 * @author nik &lt;nikboyd@sonic.net&gt;
 * @see &quot;Copyright 2010,2021 Nikolas S Boyd.&quot;
 * @see &quot;Permission is granted to copy this work provided this copyright statement is retained in all copies.&quot;
 */
public class Signature implements Signed {

<span class="fc" id="L21">    public Signature(Method m) { this.m = m; }</span>
<span class="fc" id="L22">    public static Signature from(Method method) { return nullOr(m -&gt; new Signature(m), method); }</span>

    protected Method m;
<span class="fc" id="L25">    public Method method() { return m; }</span>
<span class="fc" id="L26">    protected String selector() { return method().getName(); }</span>
<span class="nc" id="L27">    protected Class&lt;?&gt; methodClass() { return method().getDeclaringClass(); }</span>
<span class="nc" id="L28">    protected Mirror typeMirror() { return Mirror.forClass(methodClass()); }</span>
<span class="nc" id="L29">    protected Mirror resultMirror() { return Mirror.forClass(method().getReturnType()); }</span>
    protected List&lt;Typified&gt; argumentMirrors() {
<span class="nc" id="L31">        return map(wrap(method().getParameterTypes()), type -&gt; Mirror.forClass(type)); }</span>

<span class="nc bnc" id="L33" title="All 4 branches missed.">    public boolean overrides(Signature s) { return matchesSign(s) &amp;&amp; inherits(s); }</span>
    @Override public boolean overrides(Signed s) {
<span class="nc bnc" id="L35" title="All 2 branches missed.">        return matchesKind(s) ? overrides((Signature)s) : Signed.super.overrides(s); }</span>

<span class="nc" id="L37">    @Override public boolean isStatic() { return Primitive.isStatic(method()); }</span>
<span class="nc" id="L38">    public boolean matchesKind(Signed s) { return getClass().isInstance(s); }</span>
<span class="nc bnc" id="L39" title="All 4 branches missed.">    public boolean inherits(Signature s) { return !matchesClass(s) &amp;&amp; s.methodClass().isAssignableFrom(methodClass()); }</span>
<span class="nc" id="L40">    public boolean matchesClass(Signature s) { return methodClass().equals(s.methodClass()); }</span>
<span class="nc bnc" id="L41" title="All 4 branches missed.">    public boolean matchesSign(Signature s) { return selector().equals(s.selector()) &amp;&amp; matchArguments(s); }</span>
    public boolean matchArguments(Signature s) {
<span class="nc bnc" id="L43" title="All 2 branches missed.">        if (argumentCount() != s.argumentCount()) return false;</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">        if (0 == argumentCount()) return true;</span>

<span class="nc" id="L46">        List&lt;TypeName&gt; argTypeNames = argumentTypeNames();</span>
<span class="nc" id="L47">        List&lt;TypeName&gt; sargTypeNames = s.argumentTypeNames();</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">        for (int index = 0; index &lt; argTypeNames.size(); index++) {</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">            if (!argTypeNames.get(index).matches(sargTypeNames.get(index))) return false;</span>
        }
<span class="nc" id="L51">        return true;</span>
    }

<span class="fc" id="L54">    @Override public String methodName() { return Keyword.with(selector()).methodName(); }</span>
<span class="nc" id="L55">    @Override public Typified faceType() { return typeMirror(); }</span>
<span class="nc" id="L56">    @Override public String faceName() { return faceType().fullName(); }</span>

<span class="nc" id="L58">    @Override public int argumentCount() { return m.getParameterCount(); }</span>
<span class="nc" id="L59">    @Override public List&lt;Typified&gt; argumentTypes() { return argumentMirrors(); }</span>
    @Override public List&lt;TypeName&gt; argumentTypeNames() {
<span class="fc" id="L61">        final int[] index = { 0 };</span>
<span class="fc" id="L62">        Class&lt;?&gt;[] argTypes = method().getParameterTypes();</span>
<span class="fc" id="L63">        Type[] genTypes = method().getGenericParameterTypes();</span>
<span class="fc" id="L64">        return map(wrap(genTypes), type -&gt; {</span>
<span class="fc" id="L65">            String argTypeName = argTypes[index[0]].getSimpleName();</span>
<span class="fc" id="L66">            String genTypeName = genTypes[index[0]].getTypeName();</span>
<span class="fc" id="L67">            index[0]++;</span>

<span class="pc bpc" id="L69" title="1 of 2 branches missed.">            boolean isGeneric = !genTypeName.endsWith(argTypeName);</span>
<span class="fc" id="L70">            whisper(argTypeName + &quot; ?= &quot; + genTypeName);</span>
<span class="fc" id="L71">            TypeName result = TypeName.fromType(type);</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">            return isGeneric ? result.noteGeneric() : result; }); }</span>

<span class="nc" id="L74">    @Override public String fullSignature() { return shortSignature() + formatTerm(argumentSignatures()); }</span>
<span class="nc" id="L75">    @Override public String erasedSignature() { return shortSignature() + formatTerm(argumentErasures()); }</span>
<span class="nc" id="L76">    @Override public String shortSignature() { return resultMirror().fullName() + Colon + methodName(); }</span>
<span class="fc" id="L77">    @Override public String matchSignature() { return methodName() + formatTerm(argumentSignatures()); }</span>
<span class="nc" id="L78">    @Override public String matchErasure() { return methodName() + formatTerm(argumentErasures()); }</span>

<span class="nc" id="L80">    private List&lt;String&gt; argumentErasures() { return map(argumentTypes(), type -&gt; Object); }</span>
<span class="fc" id="L81">    private List&lt;String&gt; argumentSignatures() { return map(argumentTypeNames(), type -&gt; type.shortName()); }</span>

<span class="fc" id="L83">    public static String formatTerm(List&lt;String&gt; types) { return String.format(Term, formatList(types)); }</span>
<span class="fc" id="L84">    public static String formatList(List&lt;String&gt; types) { return joinWith(Comma, types); }</span>

    static final String Comma = &quot;,&quot;;
    static final String Term = &quot;(%s)&quot;;
    static final String TermEnds = &quot;[\\(\\)]&quot;;
    public static List&lt;String&gt; parse(String sig) {
<span class="nc" id="L90">        String[] parts = { Empty, sig };</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (sig.contains(Colon)) {</span>
<span class="nc" id="L92">            parts = sig.split(Colon);</span>
        }

<span class="nc" id="L95">        String[] names = parts[1].split(TermEnds);</span>
<span class="nc" id="L96">        ArrayList&lt;String&gt; results = emptyList(String.class);</span>
<span class="nc" id="L97">        results.add(parts[0]);</span>
<span class="nc" id="L98">        results.add(names[0]);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (names.length == 1) {</span>
<span class="nc" id="L100">            return results;</span>
        }

<span class="nc" id="L103">        String[] args = names[1].split(Comma);</span>
<span class="nc" id="L104">        results.addAll(wrap(args));</span>
<span class="nc" id="L105">        return results;</span>
    }

    public static Class[] argumentTypes(List&lt;String&gt; sigNames) {
<span class="nc" id="L109">        Class[] empty = { };</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (sigNames.size() &lt; 3) return empty;</span>
<span class="nc" id="L111">        ArrayList&lt;Class&gt; results = emptyList(Class.class);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        for (int index = 2; index &lt; sigNames.size(); index++) {</span>
<span class="nc" id="L113">            Class argType = Selector.from(sigNames.get(index).trim()).toClass();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            if (hasAny(argType)) results.add(argType);</span>
        }
<span class="nc" id="L116">        return unwrap(results, empty);</span>
    }

} // Signature
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>