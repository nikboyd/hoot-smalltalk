<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Library.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hoot-runtime</a> &gt; <a href="index.source.html" class="el_package">Hoot.Runtime.Maps</a> &gt; <span class="el_source">Library.java</span></div><h1>Library.java</h1><pre class="source lang-java linenums">package Hoot.Runtime.Maps;

import java.io.*;
import java.util.*;

import Hoot.Runtime.Names.Name;
import Hoot.Runtime.Faces.Named;
import Hoot.Runtime.Names.TypeName;
import Hoot.Runtime.Behaviors.Mirror;
import Hoot.Runtime.Behaviors.Typified;
import static Hoot.Runtime.Functions.Utils.*;
import static Hoot.Runtime.Names.Operator.*;
import static Hoot.Runtime.Maps.ClassPath.*;
import static Hoot.Runtime.Names.Primitive.*;

/**
 * Maintains references to all classes and interfaces imported from external packages.
 * Packages are located relative to the system class path established by the Java environment.
 *
 * @author nik &lt;nikboyd@sonic.net&gt;
 * @see &quot;Copyright 1999,2021 Nikolas S Boyd.&quot;
 * @see &quot;Permission is granted to copy this work provided this copyright statement is retained in all copies.&quot;
 */
public class Library implements TypeName.Resolver {

<span class="fc" id="L26">    protected Library() { }</span>
<span class="fc" id="L27">    public static final Library CurrentLib = new Library();</span>
<span class="nc" id="L28">    public File locate(String folder) { return CurrentPath.locate(folder); }</span>
<span class="nc" id="L29">    public boolean canLocate(Package aPackage) { return CurrentPath.canLocatePackage(aPackage); }</span>
<span class="fc" id="L30">    public static Typified findFace(String faceName) { return CurrentLib.faceNamed(faceName); }</span>

    // all uses, including tests
    public static void loadBasePaths(List&lt;File&gt; basePaths) {
<span class="nc" id="L34">        CurrentLib.configurePaths(basePaths);</span>
<span class="nc" id="L35">        CurrentLib.loadStandardLibs();</span>
<span class="nc" id="L36">        CurrentLib.loadNeededHootLibs();</span>
<span class="nc" id="L37">    }</span>

    void whileShowingOnlyDots(Runnable r) {
        try {
<span class="fc" id="L41">            clear(); CurrentPath.showOnlyDots(true); r.run();</span>
        }
        finally {
<span class="fc" id="L44">            CurrentPath.showOnlyDots(false);</span>
<span class="fc" id="L45">            printLine();</span>
        }
<span class="fc" id="L47">    }</span>

    void withoutLoadReports(Runnable r) {
        try {
<span class="fc" id="L51">            Package.reportLoads(false); r.run();</span>
        }
        finally {
<span class="fc" id="L54">            Package.reportLoads(true);</span>
        }
<span class="fc" id="L56">    }</span>

    void loadStandardLibs() {
<span class="nc" id="L59">        whileShowingOnlyDots(() -&gt; {</span>
<span class="nc" id="L60">            mapStandardPaths();</span>
<span class="nc" id="L61">            loadRootPackages();</span>
<span class="nc" id="L62">            loadConfiguredPaths();</span>
<span class="nc" id="L63">        });</span>
<span class="nc" id="L64">    }</span>

    void loadBasicLibs() {
<span class="fc" id="L67">        whileShowingOnlyDots(() -&gt; {</span>
<span class="fc" id="L68">            withoutLoadReports(() -&gt; {</span>
<span class="fc" id="L69">                mapStandardPaths();</span>
<span class="fc" id="L70">                loadRootPackages();</span>
<span class="fc" id="L71">            });</span>
<span class="fc" id="L72">        });</span>
<span class="fc" id="L73">    }</span>

<span class="fc" id="L75">    public static final String[] HootLibs = { // libs in transitive dependence order</span>
        &quot;libs-hoot&quot;, &quot;libs-smalltalk&quot;, &quot;hoot-compiler&quot;, &quot;hoot-runtime&quot;, &quot;hoot-abstracts&quot;, };

<span class="fc" id="L78">    public static List&lt;String&gt; reverseHootLibs(int count) { return reverseList(listHootLibs(count)); }</span>
<span class="fc" id="L79">    public static List&lt;String&gt; listHootLibs(int count) { return wrapLast(count, HootLibs); }</span>

    public void loadAllHootLibs() { // all libs including compiler
<span class="nc" id="L82">        withoutLoadReports(() -&gt; { clear(); CurrentPath.mapLibs(reverseHootLibs(5)); }); }</span>

    public void loadHootSmalltalkLibs() { // only standard faces + compiler
<span class="fc" id="L85">        loadBasicLibs(); withoutLoadReports(() -&gt; { CurrentPath.mapLibs(reverseHootLibs(4)); }); }</span>

    public void loadHootStandardLibs() { // all libs without compiler
<span class="nc" id="L88">        withoutLoadReports(() -&gt; {</span>
<span class="nc" id="L89">            List&lt;String&gt; list = reverseHootLibs(5); list.remove(HootLibs[2]);</span>
<span class="nc" id="L90">            clear(); CurrentPath.mapLibs(list);</span>
<span class="nc" id="L91">        });</span>
<span class="nc" id="L92">    }</span>

    public void loadHootCompilerLibs() { // runtime libs with compiler
<span class="nc" id="L95">        withoutLoadReports(() -&gt; { clear(); CurrentPath.mapLibs(reverseHootLibs(3)); }); }</span>

    public void loadHootRuntimeLibs() { // only runtime libs
<span class="fc" id="L98">        withoutLoadReports(() -&gt; { clear(); CurrentPath.mapLibs(reverseHootLibs(2)); }); }</span>

    void loadNeededHootLibs() {
        // just what's needed for this library
<span class="nc" id="L102">        int limit = HootLibs.length + 1;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        for (int count = 1; count &lt; limit; count++) {</span>
<span class="nc" id="L104">            CurrentPath.mapLibWhenNot(listHootLibs(count));</span>
        }
<span class="nc" id="L106">        printLine();</span>
<span class="nc" id="L107">    }</span>

<span class="fc" id="L109">    Map&lt;String, Typified&gt; faces = emptyMap(Typified.class);</span>
<span class="fc" id="L110">    public int countFaces() { return distinctFaces().size(); }</span>
<span class="fc" id="L111">    public boolean hasFace(String fullName) { return faces.containsKey(fullName); }</span>
<span class="nc" id="L112">    public void removeFace(String faceName) { faces.remove(faceName); }</span>
<span class="nc" id="L113">    public Typified faceFrom(Named reference) { return faceNamed(reference.fullName()); }</span>
<span class="fc" id="L114">    public Set&lt;String&gt; distinctFaces() { return selectSet(faces.keySet(), f -&gt; f.contains(Dot)); }</span>
    public Typified faceNamed(String fullName) {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (hasNo(fullName)) return Mirror.emptyMirror();</span>
<span class="fc" id="L117">        String faceName = Name.typeName(fullName);</span>
<span class="fc" id="L118">        String packageName = Name.packageName(fullName);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        return packageName.isEmpty() ? faces.get(faceName) :</span>
<span class="fc" id="L120">                packageNamed(packageName).faceNamed(faceName); }</span>

<span class="fc" id="L122">    Map&lt;String, Package&gt; packages = emptyMap(Package.class);</span>
<span class="fc" id="L123">    protected Map&lt;String, Package&gt; packages() { return this.packages; }</span>
<span class="fc" id="L124">    protected Collection&lt;Package&gt; allPackages() { return packages().values(); }</span>
<span class="fc" id="L125">    public int countPackages() { return packages().size(); }</span>
<span class="nc" id="L126">    public Set&lt;String&gt; packageNames() { return packages().keySet(); }</span>
<span class="fc" id="L127">    public void clear() { CurrentPath.clear(); faces.clear(); packages().clear(); whisper(&quot;cleared library&quot;); }</span>
    public Package packageNamed(String packageName) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (packages().containsKey(packageName)) {</span>
<span class="fc" id="L130">            return packages().get(packageName);</span>
        }

<span class="fc" id="L133">        Package result = new Package(packageName);</span>
<span class="fc" id="L134">        packages().put(packageName, result);</span>
<span class="fc" id="L135">        return result;</span>
    }

    File sourceBase;
<span class="nc" id="L139">    public String sourcePath() { return sourceBase.getAbsolutePath(); }</span>
<span class="nc" id="L140">    public boolean whenSource(String libName) { return sourcePath().contains(libName); }</span>

    File targetBase;
<span class="nc" id="L143">    public String targetPath() { return targetBase.getAbsolutePath(); }</span>

    void configurePaths(List&lt;File&gt; basePaths) {
<span class="nc" id="L146">        sourceBase = basePaths.get(0);</span>
<span class="nc" id="L147">        targetBase = basePaths.get(1);</span>
<span class="nc" id="L148">    }</span>

<span class="nc" id="L150">    public List&lt;File&gt; configuredPaths() { return wrap(sourceBase, targetBase); }</span>
    public void loadConfiguredPaths() {
<span class="nc" id="L152">        List&lt;File&gt; list = configuredPaths(); Collections.reverse(list);</span>
<span class="nc" id="L153">        list.forEach(path -&gt; CurrentPath.mapPath(path));</span>
<span class="nc" id="L154">    }</span>

    // classes whose names are shared by both Hoot and Java
<span class="nc" id="L157">    public void removeShadowedClasses() { wrap(ShadowedClasses).forEach(c -&gt; removeFace(c)); }</span>
<span class="fc" id="L158">    private static final String[] ShadowedClasses = {</span>
        &quot;Object&quot;, &quot;Boolean&quot;, &quot;Character&quot;, &quot;String&quot;,
        &quot;Number&quot;, &quot;Double&quot;,  &quot;Float&quot;,  &quot;Integer&quot;,
        &quot;Class&quot;,  &quot;Exception&quot;, &quot;Error&quot;,  &quot;Array&quot;,
    };

<span class="fc" id="L164">    public static final String[] RootPackages = { &quot;java.lang&quot;, &quot;java.lang.reflect&quot;, };</span>
<span class="fc" id="L165">    public void loadRootPackages() { wrap(RootPackages).forEach(p -&gt; packageNamed(p).loadFaces()); }</span>
<span class="fc" id="L166">    public void mapStandardPaths() { CurrentPath.mapStandardPaths(); }</span>

<span class="nc" id="L168">    public void loadEmptyPackages() { selectSet(allPackages(), p -&gt; p.needsLoad()).forEach(p -&gt; p.loadFaces()); }</span>
<span class="fc" id="L169">    public int countPackagedFaces() { return reduce(map(allPackages(), p -&gt; p.countFaces()), Integer::sum, 0); }</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">    Set&lt;Package&gt; includedPackages() { return selectSet(allPackages(), p -&gt; !excludesPackage(p.name())); }</span>

    public void addFace(Typified face) {
<span class="fc" id="L173">        String fullName = face.fullName();</span>
<span class="fc" id="L174">        String typeName = Name.typeName(fullName);</span>
<span class="fc" id="L175">        String packageName = Name.packageName(fullName);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (excludesPackage(packageName)) return;</span>

<span class="fc" id="L178">        faces.put(fullName, face);</span>
<span class="fc" id="L179">        faces.put(typeName, face);</span>
<span class="pc bpc" id="L180" title="2 of 4 branches missed.">        if (!packageName.isEmpty() &amp;&amp; typeName.startsWith(packageName)) {</span>
<span class="nc" id="L181">            typeName = typeName.substring(packageName.length() + 1);</span>
<span class="nc" id="L182">            faces.put(typeName, face);</span>
        }

<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (Name.isMetaNamed(fullName)) {</span>
<span class="fc" id="L186">            faces.put(fullName.replace(Dollar, Dot), face);</span>
<span class="fc" id="L187">            faces.put(typeName.replace(Dollar, Dot), face);</span>
        }

<span class="fc" id="L190">        whisper(&quot;added &quot; + fullName + &quot; to Library&quot;);</span>
<span class="fc" id="L191">    }</span>

<span class="fc" id="L193">    static final String[] ExcludedLibs = {</span>
        &quot;org.apache&quot;, &quot;org.slf4j&quot;, &quot;org.abego&quot;, &quot;org.stringtemplate&quot;,
        &quot;st4hidden&quot;, &quot;org.hamcrest&quot;, &quot;org.eclipse&quot;, //&quot;&quot;, &quot;&quot;,
        &quot;com.google&quot;, &quot;org.junit&quot;, &quot;org.codehaus&quot;, &quot;org.antlr&quot;, &quot;junit&quot;,
    };
<span class="fc" id="L198">    static final List&lt;String&gt; Exclusions = wrap(ExcludedLibs);</span>
<span class="fc" id="L199">    boolean excludesPackage(String packageName) { return matchAny(Exclusions, ex -&gt; packageName.startsWith(ex)); }</span>


<span class="nc" id="L202">    public Class resolveType(Named reference) { return nullOr(f -&gt; f.primitiveClass(), faceFrom(reference)); }</span>
<span class="nc" id="L203">    @Override public TypeName resolveTypeNamed(Named reference) { return TypeName.fromOther(faceFrom(reference)); }</span>

//    public boolean resolves(Named reference) {
//        if (reference.name().toString().isEmpty()) return false;
//        if (reference.name().equals(Primitive)) return true;
////        if (reference.isElementary()) return true;
////        if (reference.isGlobal()) return true;
//
//        String faceName = Name.typeName(reference.name().toString());
//        if (faceName.isEmpty()) return false;
//
//        if (Name.isMetaNamed(faceName)) {
//            faceName = Name.asMetaMember(faceName);
//        }
//
//        String packageName = Name.packageName(reference.fullName());
//        if (!packageName.isEmpty()) {
//            Typified face = faceFrom(reference);
//            if (face != null) return true;
//        }
//
//        boolean result = faces.containsKey(faceName);
//        if (result) {
////            System.out.println(&quot;Library resolved &quot; + symbol);
//        }
//        else {
////            System.out.println(&quot;Library can't resolve &quot; + faceName + &quot; from &quot; + reference.name());
//        }
//        return result;
//    }

//    public String resolveTypeName(Named reference) {
//        Class faceClass = resolveType(reference);
//        if (faceClass != null) {
//            if (Mirror.forClass(faceClass).hasMetaclass()) {
//                return MetaclassType().fullName();
//            } else {
//                return faceClass.getCanonicalName();
//            }
//        }
//
//        String symbol = Name.typeName(reference.name().toString());
//        if (faces.containsKey(symbol)) {
//            return MetaclassType().fullName();
//        }
//        return RootType().fullName();
//    }

    public static final String ChunkFileType = &quot;.st&quot;;
    public static final String SourceFileType = &quot;.hoot&quot;;
<span class="fc" id="L253">    static String LanguageType = SourceFileType;</span>
<span class="nc" id="L254">    public static String languageType() { return LanguageType; }</span>
<span class="nc" id="L255">    public static String languageType(String type) { LanguageType = type; return type; }</span>
    public static FilenameFilter sourceFileFilter() {
<span class="nc" id="L257">        return ((File dir, String name) -&gt; name.endsWith(languageType())); }</span>

    public static final String TargetFileType = &quot;.java&quot;;
<span class="fc" id="L260">    public static FilenameFilter TargetFileFilter =</span>
<span class="nc" id="L261">        ((File dir, String name) -&gt; name.endsWith(TargetFileType));</span>

    static final String DiscoveryReport = &quot;%s found %d faces&quot;;
<span class="nc bnc" id="L264" title="All 2 branches missed.">    public void reportFacesWhen(String libName) { if (whenSource(libName)) reportFaces(); }</span>
<span class="nc" id="L265">    public void reportFaces() { reportFacesDiscovered(&quot;discovery&quot;, reportedFaces()); }</span>

<span class="nc" id="L267">    List&lt;String&gt; reportedFaces() { return sortList(copyList(collectedFaces())); }</span>
    Set&lt;String&gt; collectedFaces() {
<span class="nc" id="L269">        return collectSet(fs -&gt; includedPackages().forEach(p -&gt; fs.addAll(p.qualifiedFaceNames()))); }</span>

    void reportFacesDiscovered(String reportName, List&lt;String&gt; results) {
<span class="nc" id="L272">        report(Empty);</span>
<span class="nc" id="L273">        report(format(DiscoveryReport, reportName, results.size()));</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (!results.isEmpty()) {</span>
<span class="nc" id="L275">            results.forEach(faceName -&gt; report(faceName));</span>
        }
<span class="nc" id="L277">    }</span>

    static final String PackReport = &quot;%s has %d faces&quot;;
    static final String CountReport = &quot;packs: %d, faces: %d, packedFaces: %d&quot;;
    public void reportPackagedFaces() {
<span class="fc" id="L282">        int faceCount = countFaces();</span>
<span class="fc" id="L283">        int packCount = countPackages();</span>
<span class="fc" id="L284">        int pkgdCount = countPackagedFaces();</span>
<span class="fc" id="L285">        report(format(CountReport, packCount, faceCount, pkgdCount));</span>

<span class="fc" id="L287">        includedPackages().forEach(p -&gt; {</span>
<span class="fc" id="L288">            report(format(PackReport, p.name(), p.countFaces()));</span>
<span class="fc" id="L289">        });</span>
<span class="fc" id="L290">    }</span>

} // Library
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>