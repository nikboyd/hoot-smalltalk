<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>File.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hoot-compiler</a> &gt; <a href="index.source.html" class="el_package">Hoot.Compiler.Scopes</a> &gt; <span class="el_source">File.java</span></div><h1>File.java</h1><pre class="source lang-java linenums">package Hoot.Compiler.Scopes;

import java.util.*;
import org.antlr.v4.runtime.*;

import Hoot.Runtime.Faces.*;
import Hoot.Runtime.Names.*;
import Hoot.Runtime.Emissions.*;
import Hoot.Runtime.Behaviors.*;
import Hoot.Runtime.Maps.Package;
import static Hoot.Runtime.Functions.Utils.*;
import static Hoot.Runtime.Maps.Library.*;
import static Hoot.Runtime.Emissions.Emission.*;
import static Hoot.Runtime.Maps.Package.*;

import Hoot.Compiler.Notes.Comment;
import Hoot.Compiler.Expressions.Import;
import static Hoot.Compiler.Expressions.Import.*;
import static Hoot.Runtime.Behaviors.HootRegistry.*;
import static Hoot.Runtime.Names.Keyword.Smalltalk;
import static Hoot.Runtime.Names.TypeName.EmptyType;

/**
 * A class (or type) file, including the package name, imports, and a face definition.
 *
 * @author nik &lt;nikboyd@sonic.net&gt;
 * @see &quot;Copyright 2010,2021 Nikolas S Boyd.&quot;
 * @see &quot;Permission is granted to copy this work provided this copyright statement is retained in all copies.&quot;
 */
public class File extends Scope implements UnitFile, TypeName.Resolver, ScopeSource {

<span class="fc" id="L32">    public File() { super(null); }</span>
    public File(String packageName, String faceName) {
<span class="fc" id="L34">        this(); facePackage = Package.named(packageName);</span>
<span class="fc" id="L35">        fullName = TypeName.fromName(Name.formType(packageName, faceName)); }</span>

    public static final UnitFile.Factory
<span class="fc" id="L38">    StandardUnitFactory = (faceName, packageName) -&gt; new File(packageName, faceName);</span>
<span class="fc" id="L39">    static { UnitFactory = StandardUnitFactory; }</span>

<span class="fc" id="L41">    protected Scope currentScope = this; // manage scopes with each file here</span>
<span class="fc" id="L42">    @Override protected void currentScope(Scope aScope) { this.currentScope = aScope; }</span>
<span class="fc" id="L43">    @Override public Scope currentScope() { return this.currentScope; }</span>

<span class="fc" id="L45">    public static File currentFile() { return from(Scope.currentFile()); }</span>
<span class="fc" id="L46">    public static File from(Item item) { return nullOr(f -&gt; (File)f, item.fileScope()); }</span>
<span class="fc" id="L47">    @Override public Scope makeCurrent() { return super.makeCurrent(); }</span>

<span class="fc" id="L49">    protected Map&lt;String, UnitFile&gt; peerFaces = emptyMap(UnitFile.class);</span>
<span class="fc" id="L50">    protected Map&lt;String, UnitFile&gt; peers() { return this.peerFaces; }</span>
<span class="fc" id="L51">    @Override public void clean() { super.clean(); importAllFaces(); faceScope.clean(); }</span>
<span class="fc" id="L52">    @Override public void parse() { tokenCompiler.parseTokens(); facePackage.addFace(faceScope()); }</span>
<span class="fc" id="L53">    @Override public boolean compile() { return tokenCompiler.compile(); }</span>
    @Override public void peers(Map&lt;String, UnitFile&gt; peers) {
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">        if (hasKeys(peers)) {</span>
<span class="fc" id="L56">            peers().putAll(peers);</span>
<span class="fc" id="L57">            peers.values().forEach(f -&gt; {</span>
<span class="fc" id="L58">                peers().put(f.fullName(), f);</span>
<span class="fc" id="L59">            });</span>
        }
<span class="fc" id="L61">    }</span>

    @Override public void addStandardImports() {
<span class="fc" id="L64">        addRuntimeLibraryImports();</span>
<span class="fc" id="L65">        addSmalltalkLibraryImports();</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (!packageName().startsWith(Smalltalk)) {</span>
<span class="fc" id="L67">            addHootLibraryImports();</span>
        }
<span class="fc" id="L69">    }</span>

    public void addRuntimeLibraryImports() {
<span class="fc" id="L72">        importFace(Import.runtimeFuncs(this));</span>
<span class="fc" id="L73">        importFace(Import.runtimeFaces(this));</span>
<span class="fc" id="L74">        importFace(Import.runtimeValues(this));</span>
<span class="fc" id="L75">        importFace(Import.runtimeBlocks(this));</span>
<span class="fc" id="L76">    }</span>

    public void addSmalltalkLibraryImports() {
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (!SmalltalkCore.typeName().equals(packageName())) {</span>
<span class="fc" id="L80">            importFace(Import.smalltalkCore(this));</span>
        }

<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (!SmalltalkBlocks.typeName().equals(packageName())) {</span>
<span class="fc" id="L84">            importFace(Import.smalltalkBlocks(this));</span>
        }
<span class="fc" id="L86">    }</span>

    public void addHootLibraryImports() {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (!HootBehaviors.typeName().equals(packageName())) {</span>
<span class="fc" id="L90">            importFace(Import.hootBehaviors(this));</span>
<span class="fc" id="L91">            importFace(Import.from(this, NilType()));</span>
<span class="fc" id="L92">            importFace(Import.from(this, RootType()));</span>
<span class="fc" id="L93">            importFace(Import.from(this, TrueType()));</span>
<span class="fc" id="L94">            importFace(Import.from(this, FalseType()));</span>
<span class="fc" id="L95">            importFace(Import.from(this, BooleanType()));</span>
        }

<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (!HootMagnitudes.typeName().equals(packageName())) {</span>
<span class="fc" id="L99">            importFace(Import.hootMagnitudes(this));</span>
<span class="fc" id="L100">            importFace(Import.from(this, IntegerType()));</span>
<span class="fc" id="L101">            importFace(Import.from(this, CharacterType()));</span>
<span class="fc" id="L102">            importFace(Import.from(this, FloatType()));</span>
<span class="fc" id="L103">            importFace(Import.from(this, DoubleType()));</span>
        }

<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (!HootCollections.typeName().equals(packageName())) {</span>
<span class="fc" id="L107">            importFace(Import.hootCollections(this));</span>
<span class="fc" id="L108">            importFace(Import.from(this, StringType()));</span>
        }
<span class="fc" id="L110">    }</span>

<span class="fc" id="L112">    protected List&lt;Comment&gt; cachedComments = emptyList(Comment.class);</span>
<span class="fc" id="L113">    public void cacheComments(List&lt;Comment&gt; comments) { cachedComments.addAll(comments); }</span>
    public Comment getComment(int index) {
<span class="pc bpc" id="L115" title="2 of 4 branches missed.">        return (index &gt;= 0 &amp;&amp; index &lt; cachedComments.size()) ? cachedComments.get(index) : null; }</span>

<span class="fc" id="L117">    protected List&lt;Import&gt; faceImports = emptyList(Import.class);</span>
<span class="fc" id="L118">    public void importFace(Import faceImport) { faceImports.add(faceImport); }</span>
<span class="fc" id="L119">    public List&lt;Import&gt; faceImports() { return faceImports; }</span>

    public TypeName importedTypeNamed(Named reference) {
<span class="nc bnc" id="L122" title="All 2 branches missed.">        return (importedFaces().isEmpty()) ? null : importedFaces().get(reference.name().toString()); }</span>

<span class="fc" id="L124">    protected Map&lt;String, TypeName&gt; importedFaces = emptyMap(TypeName.class);</span>
<span class="fc" id="L125">    public Map&lt;String, TypeName&gt; importedFaces() { importAllFaces(); return this.importedFaces; }</span>
    private void importAllFaces() {
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">        if (faceImports().isEmpty() || !importedFaces.isEmpty()) return;</span>
<span class="fc" id="L128">        faceImports().forEach((faceImport) -&gt; { faceImport.addToFaces(importedFaces); });</span>
<span class="fc" id="L129">    }</span>

<span class="fc" id="L131">    TypeName fullName = EmptyType;</span>
<span class="nc" id="L132">    public void fullName(String fullName) { this.fullName = TypeName.fromName(fullName); }</span>
<span class="fc" id="L133">    public String initialName() { return this.fullName.shortName(); }</span>
<span class="fc" id="L134">    @Override public String name() { return initialName(); }</span>
<span class="fc" id="L135">    @Override public String fullName() { return facePackage().qualify(initialName()); }</span>
<span class="fc" id="L136">    @Override public String description() { return &quot;File &quot; + initialName(); }</span>

<span class="fc" id="L138">    Face faceScope = new Face(this);</span>
<span class="fc" id="L139">    @Override public Face faceScope() { return faceScope; }</span>
<span class="fc" id="L140">    @Override public Scope facialScope() { return this.faceScope(); }</span>
<span class="nc" id="L141">    public String faceName() { return faceScope.name(); }</span>

    public Typified faceNamed(String faceName) {
<span class="fc" id="L144">        String baseFace = Name.withoutMeta(faceName);</span>
<span class="fc" id="L145">        String searchName = Name.asMetaMember(faceName);</span>
<span class="fc" id="L146">        boolean metaNamed = Name.isMetaNamed(faceName);</span>

<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (importedFaces().containsKey(searchName)) {</span>
<span class="fc" id="L149">            Typified result = importedFaces().get(searchName).findType();</span>
<span class="fc" id="L150">            reportFace(result, searchName, &quot;imports&quot;);</span>
<span class="fc" id="L151">            return result;</span>
        }

<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (peers().containsKey(baseFace)) {</span>
<span class="fc" id="L155">            Typified result = facePackage().faceNamed(baseFace);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">            if (Face.class.isInstance(result)) {</span>
<span class="fc" id="L157">                Face found = (Face)result;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                if (!found.isSigned()) found.file().parse();</span>
            }
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">            if (metaNamed) result = nullOr(r -&gt; r.$class(), result);</span>
<span class="fc" id="L161">            reportFace(result, searchName, &quot;peers&quot;);</span>
<span class="fc" id="L162">            return result;</span>
        }

<span class="fc" id="L165">        Typified result = findFace(searchName);</span>
<span class="fc" id="L166">        boolean known = reportWhetherKnown(&quot;library&quot;, result, searchName);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (!known) reportFace(result, searchName, &quot;library&quot;);</span>
<span class="fc" id="L168">        return result;</span>
    }

    static final String FaceReport = &quot;found %s from %s with '%s'&quot;;
    void reportFace(Typified face, String name, String source) {
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (hasSome(face)) whisper(format(FaceReport, face.fullName(), source, name));</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        else if (&quot;library&quot;.equals(source)) {</span>
<span class="fc" id="L175">            whisper(format(FaceReport, &quot;null&quot;, source, name));</span>
        }
<span class="fc" id="L177">    }</span>

<span class="fc" id="L179">    TokenCompiler tokenCompiler = new TokenCompiler(this);</span>
<span class="nc" id="L180">    @Override public TokenStream tokenStream() { return tokenCompiler.tokenStream(); }</span>
<span class="fc" id="L181">    @Override public boolean isFile() { return true; }</span>
<span class="fc" id="L182">    @Override public int nestLevel() { return 0; }</span>
<span class="fc" id="L183">    public String notice() { return this.faceScope.notes().notice(); }</span>

<span class="fc" id="L185">    protected Package facePackage = null;</span>
<span class="fc" id="L186">    public Package facePackage() { return facePackage; }</span>
<span class="fc" id="L187">    public String packageName() { return facePackage.name(); }</span>
<span class="nc" id="L188">    public String packagePathname() { return facePackage.pathname(); }</span>
<span class="nc" id="L189">    public void namePackage(String packageName) { facePackage = Package.named(packageName); }</span>

<span class="nc" id="L191">    public boolean needsMagnitudes() { return facePackage.definesBehaviors(); }</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">    public boolean needsCollections() { return facePackage.definesBehaviors() || facePackage.definesMagnitudes(); }</span>

<span class="fc" id="L194">    public String sourceFilename() { return initialName() + SourceFileType; }</span>
<span class="fc" id="L195">    public String targetFilename() { return initialName() + TargetFileType; }</span>

    public java.io.File sourceFile() {
<span class="fc" id="L198">        java.io.File packageFolder = facePackage.sourceFolder();</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (packageFolder == null) return null;</span>
<span class="fc" id="L200">        return new java.io.File(packageFolder, sourceFilename());</span>
    }

    public java.io.File targetFile() {
<span class="nc" id="L204">        java.io.File packageFolder = facePackage.targetFolder();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (packageFolder == null) return null;</span>
<span class="nc" id="L206">        return new java.io.File(packageFolder, targetFilename());</span>
    }

//    @Override public boolean resolves(Named reference) { return faceLibrary.resolves(reference); }
//    @Override public Scope scopeResolving(Named reference) { return resolves(reference) ? this : null; }
//    @Override public Class resolveType(Named reference) { return faceLibrary.resolveType(reference); }

//    @Override public String resolveTypeName(Named reference) {
//        String name = reference.name().toString();
//        if (!importedFaces().isEmpty()) {
//            if (importedFaces().containsKey(name)) {
//                return importedFaces().get(name).fullName();
//            }
//        }
//
//        Typified face = facePackage.faceNamed(name);
//        if (face != null) return face.fullName();
//
//        return faceLibrary.resolveTypeName(reference);
//    }

    @Override public TypeName resolveTypeNamed(Named reference) {
<span class="nc" id="L228">        String name = reference.name().toString();</span>
<span class="nc" id="L229">        TypeName result = importedTypeNamed(reference);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (result != null) return result;</span>

<span class="nc" id="L232">        Typified face = facePackage.faceNamed(name);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (face != null) return TypeName.fromOther(face);</span>

<span class="nc" id="L235">        return CurrentLib.resolveTypeNamed(reference);</span>
    }

<span class="fc" id="L238">    public Emission emitPackage() { return emitStatement(emit(&quot;Package&quot;).name(packageName())); }</span>
<span class="fc" id="L239">    public List&lt;Emission&gt; emitImports() { return map(faceImports, face -&gt; face.emitItem()); }</span>
<span class="fc" id="L240">    @Override public Emission emitScope() { return faceScope().emitScope(emitLibraryScope()); }</span>
<span class="fc" id="L241">    public Emission emitLibraryScope() { return emitLibraryScope(notice(), emitPackage(), emitImports()); }</span>

} // File
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>