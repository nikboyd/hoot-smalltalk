<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HootMain.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hoot-compiler</a> &gt; <a href="index.source.html" class="el_package">Hoot.Compiler</a> &gt; <span class="el_source">HootMain.java</span></div><h1>HootMain.java</h1><pre class="source lang-java linenums">package Hoot.Compiler;

import java.io.*;
import java.util.*;
import org.apache.commons.cli.*;
import org.apache.commons.cli.Option.*;
import org.apache.commons.lang3.ArrayUtils;

import Hoot.Runtime.Faces.*;
import Hoot.Runtime.Maps.Package;
import Hoot.Runtime.Values.Variable;

import static Hoot.Compiler.Scopes.File.*;
import static Hoot.Runtime.Maps.Package.*;
import static Hoot.Runtime.Names.Primitive.*;
import static Hoot.Runtime.Functions.Utils.*;
import static Hoot.Runtime.Functions.Exceptional.*;
import static Hoot.Runtime.Maps.Library.SourceFileType;
import static Hoot.Runtime.Maps.Library.loadBasePaths;

/**
 * Compiles Hoot code to Java classes and types.
 * Takes command line arguments and thereby instructs the compiler.
 *
 * @author nik &lt;nikboyd@sonic.net&gt;
 * @see &quot;Copyright 2010,2021 Nikolas S Boyd.&quot;
 * @see &quot;Permission is granted to copy this work provided this copyright statement is retained in all copies.&quot;
 */
<span class="fc" id="L29">public class HootMain implements Logging {</span>

    public static final String Source = &quot;source&quot;;
    public static final String TestSource = &quot;test-source&quot;;
    public static final String SourceTest = &quot;src/test/hoot&quot;;
    public static final String SourcePath = &quot;src/main/hoot&quot;;

    public static final String Target = &quot;target&quot;;
    public static final String TargetTest = &quot;target/generated-test-sources/hoot-maven-plugin&quot;;
    public static final String TargetPath = &quot;target/generated-sources/hoot-maven-plugin&quot;;

    static final String VersionReport = &quot;found JDK %s, generated code will be compatible with JDK %s&quot;;
    static { // check and report java version
<span class="fc" id="L42">        String message = String.format(VersionReport, Variable.javaVersion(), Variable.javaCompatibility());</span>
<span class="fc" id="L43">        printLine(); printLine(message);</span>
    }

<span class="fc" id="L46">    public static void main(String... args) { mainly().parseCommand(args).runCommand(); }</span>
<span class="fc" id="L47">    public static HootMain mainly() { return new HootMain(); }</span>

<span class="fc" id="L49">    final CommandLineParser parser = new DefaultParser();</span>
<span class="fc" id="L50">    CommandLine parseArgs(String[] args) { return nullOrTryLoudly(() -&gt; parser.parse(availableOptions(), args)); }</span>

    CommandLine command;
<span class="fc" id="L53">    HootMain parseCommand(String[] args) { command = parseArgs(args); return this; }</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">    HootMain runCommand() { if (helpWanted()) printHelp(); else compilePackages(); return this; }</span>

<span class="fc" id="L56">    boolean helpWanted() { return falseOr((c) -&gt; c.hasOption(Help), command); }</span>
<span class="fc" id="L57">    boolean testWanted() { return falseOr((c) -&gt; c.hasOption(TestOnly), command); }</span>

<span class="fc" id="L59">    boolean hasMainSource() { return falseOr((c) -&gt; c.hasOption(Source), command); }</span>
<span class="fc" id="L60">    boolean hasTestSource() { return falseOr((c) -&gt; c.hasOption(TestSource), command); }</span>
<span class="nc bnc" id="L61" title="All 4 branches missed.">    boolean needsDefaultSource() { return !hasMainSource() &amp;&amp; !hasTestSource(); }</span>

<span class="fc" id="L63">    static String normalPath(String p) { return Package.normalPath(p); }</span>
<span class="nc" id="L64">    String defaultSourcePath() { return defaultSourceFolder().getPath(); }</span>
    File defaultSourceFolder() {
<span class="nc" id="L66">        return new File(removeTail(normalPath(targetTail()), targetFolder.getPath()), normalPath(sourceTail())); }</span>
    String removeTail(String tail, String path) {
<span class="nc bnc" id="L68" title="All 2 branches missed.">        return (path.endsWith(tail)) ? path.substring(0, path.length() - tail.length()) : path; }</span>

<span class="pc bpc" id="L70" title="1 of 2 branches missed.">    String targetTail() { return hasTestSource() ? TargetTest : TargetPath; }</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">    String sourceTail() { return hasTestSource() ? SourceTest : SourcePath; }</span>
    String selectedSource() { // figure intended source from supplied args
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        return hasTestSource() ? testSourcePath() :</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">               hasMainSource() ? sourcePath() : defaultSourcePath(); }</span>

<span class="fc" id="L76">    String targetPath() { return emptyOr((c) -&gt; c.getOptionValue(Folder, targetTail()), command); }</span>
<span class="fc" id="L77">    String sourcePath() { return emptyOr((c) -&gt; c.getOptionValue(Source, sourceTail()), command); }</span>
<span class="fc" id="L78">    String sourceType() { return emptyOr((c) -&gt; c.getOptionValue(Language, SourceFileType), command); }</span>

<span class="nc" id="L80">    String testTargetPath() { return emptyOr((c) -&gt; c.getOptionValue(Folder, TargetTest), command); }</span>
<span class="nc" id="L81">    String testSourcePath() { return emptyOr((c) -&gt; c.getOptionValue(TestSource, SourceTest), command); }</span>

    static final String WorkPath = &quot;working&quot;;
    public static final String BasePath = &quot;user.dir&quot;;
<span class="fc" id="L85">    String basePath() { return emptyOr((c) -&gt; c.getOptionValue(Base, systemValue(BasePath)), command); }</span>

<span class="fc" id="L87">    final List&lt;String&gt; packageList = emptyList(String.class);</span>
<span class="fc" id="L88">    List&lt;String&gt; packages() { return this.packageList; }</span>
<span class="fc" id="L89">    boolean noPackages() { return packages().isEmpty(); }</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">    boolean somePackages() { return !noPackages(); }</span>

<span class="fc" id="L92">    List&lt;String&gt; packageList() { return wrap(command.getOptionValues(Packages)); }</span>
    void cachePackages() {
<span class="pc bnc" id="L94" title="All 2 branches missed.">        packages().addAll(selectList(packageList(), p -&gt; !p.isEmpty()));</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (noPackages()) {</span>
<span class="fc" id="L96">            packages().addAll(collectPackagesUnder(sourceFolder));</span>
        }
<span class="fc" id="L98">    }</span>

    List&lt;String&gt; collectPackagesUnder(File hootFolder) {
<span class="fc" id="L101">        return collectList(list -&gt; {</span>
<span class="fc" id="L102">            File[] subFolders = hootFolder.listFiles(FolderFilter);</span>
<span class="fc" id="L103">            wrap(subFolders).forEach(f -&gt; {</span>
<span class="fc" id="L104">                File packageFolder = new File(hootFolder, f.getName());</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                if (packageFolder.isDirectory()) {</span>
<span class="fc" id="L106">                    String packageName = Package.nameFrom(sourceFolder, packageFolder);</span>
<span class="fc" id="L107">                    list.addAll(collectPackagesUnder(packageFolder));</span>
<span class="fc" id="L108">                    list.add(packageName);</span>
                }
<span class="fc" id="L110">            });</span>
<span class="fc" id="L111">        });</span>
    }

<span class="fc" id="L114">    static final String[] Skipped = { &quot;resources&quot;, &quot;java&quot; };</span>
<span class="fc" id="L115">    static final List&lt;String&gt; SkippedFolders = wrap(Skipped);</span>
<span class="pc bpc" id="L116" title="1 of 4 branches missed.">    static final FileFilter FolderFilter = (f) -&gt; f.isDirectory() &amp;&amp; !SkippedFolders.contains(f.getName());</span>

<span class="fc" id="L118">    final List&lt;String&gt; libsList = emptyList(String.class);</span>
<span class="fc" id="L119">    List&lt;String&gt; libs() { return this.libsList; }</span>
<span class="fc" id="L120">    void cacheLibs() { libs().addAll(libsList()); }</span>
<span class="fc" id="L121">    List&lt;String&gt; libsList() { return wrap(command.getOptionValues(Libs)); }</span>

    public static final String Compiler = &quot;hoot-compiler&quot;;
<span class="fc" id="L124">    void printHelp() { helpPrinter().printHelp(Compiler, availableOptions()); }</span>
    HelpFormatter helpPrinter() {
<span class="fc" id="L126">        HelpFormatter f = new HelpFormatter();</span>
<span class="fc" id="L127">        f.setWidth(120);</span>
<span class="fc" id="L128">        return f;</span>
    }

<span class="fc" id="L131">    Options availableOptions() { return collectWith(new Options(), listOptions(), (opts,opt) -&gt; opts.addOption(opt)); }</span>
<span class="fc" id="L132">    List&lt;Option&gt; listOptions() { return wrap(</span>
<span class="fc" id="L133">        baseOption(), sourceOption(), targetOption(), packageOption(),</span>
<span class="fc" id="L134">        testSourceOption(), testOption(), helpOption(), languageOption()</span>
        ); }

    String basePath;
    File baseFolder;
    File sourceFolder;
    File targetFolder;

    void prepareFolders() {
        // validate the paths
<span class="fc" id="L144">        basePath = basePath();</span>
<span class="fc" id="L145">        baseFolder = locate(WorkPath, basePath);</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (baseFolder == null) return;</span>

<span class="fc" id="L148">        targetFolder = locate(Target, targetPath(), targetTail());</span>
<span class="fc" id="L149">        sourceFolder = locate(Source, selectedSource(), sourceTail());</span>
<span class="fc" id="L150">    }</span>

    static final String Adding = &quot;adding&quot;;
    static final String RelativePrefix = &quot;../&quot;;
    static final String ClassesPath = &quot;target/classes&quot;;
<span class="fc" id="L155">    final List&lt;File&gt; basicPaths = emptyList(File.class);</span>
<span class="nc" id="L156">    void addBasicPath(String relativePath) { basicPaths.add(locate(Adding, relativePath, ClassesPath)); }</span>
    void addQualifiedPath(String relativePath, String qualifier) {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (basePath.endsWith(qualifier)) basicPaths.add(locate(Adding, RelativePrefix + relativePath, ClassesPath)); }</span>

    void addPath(String relativePath, String... qualifiers) {
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (hasAny(qualifiers)) addQualifiedPath(relativePath, qualifiers[0]); else addBasicPath(relativePath); }</span>

    void loadPaths() {
<span class="fc" id="L164">        File[] paths = { sourceFolder, targetFolder, };</span>
<span class="fc" id="L165">        basicPaths.addAll(wrap(paths));</span>
<span class="fc" id="L166">        loadBasePaths(wrap(paths));</span>
<span class="fc" id="L167">        UnitFactory = StandardUnitFactory;</span>
<span class="fc" id="L168">        Hoot.Compiler.Scopes.File.fileType(sourceType());</span>
<span class="fc" id="L169">    }</span>

    static final String Comparison = &quot;comparing: '%s' and '%s'&quot;;
<span class="fc" id="L172">    File locate(String name, String... paths) { return reportFolder(name, locateCode(name, paths)); }</span>
    File locateCode(String folderName, String... folderPaths) {
<span class="fc" id="L174">        File folder = new File(normalPath(folderPaths[0]));</span>
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">        if (WorkPath.equals(folderName) || folder.isAbsolute()) return folder;</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (folderPaths.length == 1) return new File(baseFolder, normalPath(folderPaths[0]));</span>
<span class="fc" id="L177">        return locateRelative(folderName, normalPath(folderPaths[0]), normalPath(folderPaths[1])) ;</span>
    }

    // paths have already been normalized
    File locateRelative(String folderName, String relativePath, String soughtPath) {
<span class="fc" id="L182">        File folder = new File(relativePath);</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (relativePath.endsWith(soughtPath)) return folder;</span>
<span class="fc" id="L184">        File possible = new File(folder, soughtPath);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (Target.equals(folderName)) return possible;</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        return possible.exists() ? possible : folder;</span>
    }

    static final String Pad = &quot;  &quot;;
    File reportFolder(String folderName, File folder) {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (folderName.length() &lt; Missing.length())</span>
<span class="fc" id="L192">            folderName = Pad + folderName; // adjust name</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (folder.exists()) { // found folder</span>
<span class="fc" id="L195">            reportLoudly(folderName, folder); return folder; }</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        else if (Target.equals(folderName.trim())) {</span>
<span class="fc" id="L197">            folder.mkdirs(); // create a missing target</span>
<span class="fc" id="L198">            reportLoudly(Created, folder); return folder; }</span>
        else { // report missing folder
<span class="nc" id="L200">            reportLoudly(Missing, folder); return null; }</span>
    }

    static final String Created = &quot; CREATED&quot;;
    static final String Missing = &quot; WITHOUT&quot;;
    static final String FolderFound = &quot;%s folder = %s&quot;;
    void reportLoudly(String folderName, File folder) {
<span class="fc" id="L207">        runLoudly(() -&gt; report(format(FolderFound, folderName, folder.getCanonicalPath()))); }</span>


<span class="fc" id="L210">    void compilePackages() { prepareCompile(); compileOrTest(); }</span>
<span class="fc" id="L211">    void prepareCompile() { prepareFolders(); cacheLibs(); cachePackages(); loadPaths(); }</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">    void compileOrTest() { if (testWanted()) reportPackages(); else compileAllPackages(); }</span>
<span class="fc" id="L213">    void compileAllPackages() { packages().forEach(p -&gt; compilePackage(Package.named(p))); }</span>

    static final String PackageReport = &quot;packages: %s&quot;;
<span class="nc" id="L216">    void reportPackages() { report(format(PackageReport, joinWith(Blank, packages()))); testPackages(); }</span>
<span class="nc" id="L217">    void testPackages() { packages().forEach((p) -&gt; { reportPackage(Package.named(p)); }); }</span>

    static final String PackageFound = &quot;source folder located: %s&quot;;
    static final String PackageMissing = &quot;no &quot; + PackageFound;
<span class="nc" id="L221">    void reportPackage(Package p) { File folder = p.sourceFolder();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        String reportFormat = folder.exists() ? PackageFound : PackageMissing;</span>
<span class="nc" id="L223">        runLoudly(() -&gt; report(format(reportFormat, folder.getCanonicalPath()))); }</span>

    static final String HootFileType = &quot;.hoot&quot;;
<span class="pc" id="L226">    static final FileFilter HootFilter = (f) -&gt; isHoot(f);</span>
<span class="nc bnc" id="L227" title="All 4 branches missed.">    static boolean isHoot(File f) { return f.isFile() &amp;&amp; f.getPath().endsWith(HootFileType); }</span>

    static final String Translation = &quot;translating %s&quot;;
    void compilePackage(Package p) {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (!p.sourceFaces().isEmpty()) {</span>
<span class="fc" id="L232">            report(Empty);</span>
<span class="fc" id="L233">            report(format(Translation, p.name()));</span>
<span class="fc" id="L234">            runLoudly(() -&gt; { // any throwable is seriously jacked! --nik</span>
<span class="fc" id="L235">                Map&lt;String, UnitFile&gt; fileMap = p.parseSources();</span>
<span class="fc" id="L236">                fileMap.values().forEach(f -&gt; f.compile());</span>
<span class="fc" id="L237">            });</span>
        }
<span class="fc" id="L239">    }</span>

    static final String Dash = &quot;-&quot;;
    static final String Optional = Dash + Dash;
    public static final String Help = &quot;help&quot;;
<span class="fc" id="L244">    Option helpOption() { return buildOption(Help, &quot;optional: displays this help&quot;).build(); }</span>

    public static final String TestOnly = &quot;only-test&quot;;
<span class="fc" id="L247">    Option testOption() { return buildOption(TestOnly, &quot;optional: only tests compile arguments&quot;).build(); }</span>

    public static final String Test = &quot;test&quot;; // note mojo alias for only-test
<span class="fc" id="L250">    public static final String[] Optionals = { Help, Test };</span>
<span class="fc" id="L251">    public static final Map&lt;String, String&gt; OptionalBools = emptyMap();</span>
    static {
<span class="fc" id="L253">        OptionalBools.put(Help, &quot;false&quot;);</span>
<span class="fc" id="L254">        OptionalBools.put(Test, &quot;false&quot;);</span>
<span class="fc" id="L255">    }</span>

    static final String Base = &quot;base&quot;;
<span class="fc" id="L258">    Option baseOption() { return baseOptBuilder().optionalArg(true).hasArg().build(); }</span>
<span class="fc" id="L259">    Builder baseOptBuilder() { return buildOption(Base, Base+Path, &quot;optional: base folder path, assumes 'user.dir' value&quot;); }</span>

<span class="fc" id="L261">    Option sourceOption() { return sourceOptBuilder().optionalArg(true).hasArg().build(); }</span>
<span class="fc" id="L262">    Builder sourceOptBuilder() { return buildOption(Source, Source+Path, &quot;optional: Hoot sources folder path&quot;); }</span>

<span class="fc" id="L264">    Option testSourceOption() { return testSourceBuilder().optionalArg(true).hasArg().build(); }</span>
<span class="fc" id="L265">    Builder testSourceBuilder() { return buildOption(TestSource, Source+Path, &quot;optional: Hoot test sources folder path&quot;); }</span>

    static final String Path = &quot;Path&quot;;
    public static final String Folder = &quot;folder&quot;;
<span class="fc" id="L269">    Option targetOption() { return targetOptBuilder().optionalArg(false).hasArg().build(); }</span>
<span class="fc" id="L270">    Builder targetOptBuilder() { return buildOption(Folder, Target+Path, &quot;required: Java target folder path&quot;); }</span>

    static final char BLANK = ' ';
    static final String Libs = &quot;libs&quot;;
<span class="nc" id="L274">    Option libsOption() { return libsOptBuilder().optionalArg(true).valueSeparator(BLANK).hasArgs().build(); }</span>
<span class="nc" id="L275">    Builder libsOptBuilder() { return buildOption(Libs, Libs+Path, &quot;library JARs&quot;); }</span>

    static final String LangName = &quot;languageName&quot;;
    static final String Language = &quot;language&quot;;
<span class="fc" id="L279">    Option languageOption() { return languageBuilder().optionalArg(true).hasArg().build(); }</span>
<span class="fc" id="L280">    Builder languageBuilder() { return buildOption(Language, LangName, &quot;optional: language name, .st or .hoot = default&quot;); }</span>

    static final String PackNames = &quot;packageNames&quot;;
    public static final String Packages = &quot;packages&quot;;
<span class="fc" id="L284">    Option packageOption() { return packageOptBuilder().optionalArg(true).valueSeparator(BLANK).hasArgs().build(); }</span>
<span class="fc" id="L285">    Builder packageOptBuilder() { return buildOption(Packages, PackNames, &quot;optional: packages to compile, none = all&quot;); }</span>

<span class="fc" id="L287">    public static String shortened(String optionName) { return Dash + shortOption(optionName); }</span>
<span class="fc" id="L288">    static String shortOption(String optionName) { return optionName.substring(0, 1); }</span>
<span class="fc" id="L289">    Builder buildOption(String optionName, String text) { return buildOption(optionName, Empty, text); }</span>

    static final String Optioned = &quot;Option&quot;;
    Builder buildOption(String optionName, String argName, String text) {
<span class="fc" id="L293">        return Option.builder(shortOption(optionName))</span>
<span class="fc" id="L294">                .longOpt(optionName).required(false).desc(text)</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">                .argName(argName.isEmpty() ? optionName+Optioned : argName); }</span>

    public static String[] buildCommand(String path, String... options) {
<span class="fc" id="L298">        String[] args = { shortened(Folder), path, }; return ArrayUtils.addAll(args, options); }</span>

} // HootMain
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>