'From Squeak6.0alpha of 8 March 2021 [latest update: #20288] on 2 July 2022 at 10:22:34 am'!Object subclass: #Point	instanceVariableNames: 'x y'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Point commentStamp: '<historical>' prior: 0!'I represent an x-y pair of numbers usually designating a location on the screen.'!!Point methodsFor: 'accessing' stamp: 'jrd 5/26/2010 12:32'!u	^x! !!Point methodsFor: 'accessing' stamp: 'jrd 5/26/2010 12:32'!v	^y! !!Point methodsFor: 'accessing'!x	"Answer the x coordinate."	^x! !!Point methodsFor: 'accessing'!y	"Answer the y coordinate."	^y! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!* arg 	"Answer a Point that is the product of the receiver and arg."	arg isPoint ifTrue: [^ (x * arg x) @ (y * arg y)].	^ arg adaptToPoint: self andSend: #*! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!+ arg 	"Answer a Point that is the sum of the receiver and arg."	arg isPoint ifTrue: [^ (x + arg x) @ (y + arg y)].	^ arg adaptToPoint: self andSend: #+! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!- arg 	"Answer a Point that is the difference of the receiver and arg."	arg isPoint ifTrue: [^ (x - arg x) @ (y - arg y)].	^ arg adaptToPoint: self andSend: #-! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!/ arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x / arg x) @ (y / arg y)].	^ arg adaptToPoint: self andSend: #/! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!// arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x // arg x) @ (y // arg y)].	^ arg adaptToPoint: self andSend: #//! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!\\ arg 	"Answer a Point that is the mod of the receiver and arg."	arg isPoint ifTrue: [^ (x \\ arg x) @ (y \\ arg y)].	^ arg adaptToPoint: self andSend: #\\! !!Point methodsFor: 'arithmetic'!abs	"Answer a Point whose x and y are the absolute values of the receiver's x 	and y."	^ x abs @ y abs! !!Point methodsFor: 'arithmetic' stamp: 'TRee 6/3/2004 11:09'!reciprocal    " Answer a Point with coordinates that are the reciprocals of mine. "    " Method was missing from release. "    " 20040301 20:50:35 TRee(Squeak3.6-5429-tree07.38) "    ^ x reciprocal @ y reciprocal.! !!Point methodsFor: 'comparing'!< aPoint 	"Answer whether the receiver is above and to the left of aPoint."	^x < aPoint x and: [y < aPoint y]! !!Point methodsFor: 'comparing'!<= aPoint 	"Answer whether the receiver is neither below nor to the right of aPoint."	^x <= aPoint x and: [y <= aPoint y]! !!Point methodsFor: 'comparing'!= aPoint	self species = aPoint species		ifTrue: [^x = aPoint 	"Refer to the comment in Object|=." x and: [y = aPoint y]]		ifFalse: [^false]! !!Point methodsFor: 'comparing'!> aPoint 	"Answer whether the receiver is below and to the right of aPoint."	^x > aPoint x and: [y > aPoint y]! !!Point methodsFor: 'comparing'!>= aPoint 	"Answer whether the receiver is neither above nor to the left of aPoint."	^x >= aPoint x and: [y >= aPoint y]! !!Point methodsFor: 'comparing' stamp: 'laza 4/8/2010 11:26'!closeTo: aPoint	^(x closeTo: aPoint x) and: [y closeTo: aPoint y]! !!Point methodsFor: 'comparing' stamp: 'SqR 11/3/2000 17:08'!hash	"Hash is reimplemented because = is implemented."	^(x hash hashMultiply + y hash) hashMultiply! !!Point methodsFor: 'comparing'!max: aPoint 	"Answer the lower right corner of the rectangle uniquely defined by the 	receiver and the argument, aPoint."	^ (x max: aPoint x) @ (y max: aPoint y)! !!Point methodsFor: 'comparing'!min: aPoint 	"Answer the upper left corner of the rectangle uniquely defined by the 	receiver and the argument, aPoint."	^ (x min: aPoint x) @ (y min: aPoint y)! !!Point methodsFor: 'comparing'!min: aMin max: aMax 	^ (self min: aMin) max: aMax! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:45'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Point methodsFor: 'converting' stamp: 'di 11/9/1998 12:44'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Point."	^ rcvr@rcvr perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:47'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Point methodsFor: 'converting'!asFloatPoint	^ x asFloat @ y asFloat! !!Point methodsFor: 'converting'!asIntegerPoint	^ x asInteger @ y asInteger! !!Point methodsFor: 'converting' stamp: 'wiz 11/25/2004 12:48'!asNonFractionalPoint(x isFraction or: [y isFraction])	ifTrue:[^ x asFloat @ y asFloat]! !!Point methodsFor: 'converting'!asPoint	"Answer the receiver itself."	^self! !!Point methodsFor: 'copying'!deepCopy	"Implemented here for better performance."	^x deepCopy @ y deepCopy! !!Point methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Point methodsFor: 'geometry' stamp: 'laza 1/24/2000 03:44'!isInsideCircle: a with: b with: c 	"Returns TRUE if self is inside the circle defined by the     	points a, b, c. See Guibas and Stolfi (1985) p.107"	^ (a dotProduct: a)		* (b triangleArea: c with: self) - ((b dotProduct: b)			* (a triangleArea: c with: self)) + ((c dotProduct: c)			* (a triangleArea: b with: self)) - ((self dotProduct: self)			* (a triangleArea: b with: c)) > 0.0! !!Point methodsFor: 'geometry' stamp: 'laza 1/6/2000 10:30'!sideOf: otherPoint 	"Returns #left, #right or #center if the otherPoint lies to the left, right 	or on the line given by the vector from 0@0 to self"	| side |	side := (self crossProduct: otherPoint) sign.	^ {#right. #center. #left} at: side + 2! !!Point methodsFor: 'geometry' stamp: 'ar 4/6/2000 18:37'!to: end1 intersects: start2 to: end2 	"Returns true if the linesegment from start1 (=self) to end1 intersects      	    with the segment from start2 to end2, otherwise false."	| start1 sideStart sideEnd |	start1 := self.	(((start1 = start2 or: [end1 = end2])		or: [start1 = end2])		or: [start2 = end1])		ifTrue: [^ true].	sideStart := start1 to: end1 sideOf: start2.	sideEnd := start1 to: end1 sideOf: end2.	sideStart = sideEnd ifTrue: [^ false].	sideStart := start2 to: end2 sideOf: start1.	sideEnd := start2 to: end2 sideOf: end1.	sideStart = sideEnd ifTrue: [^ false].	^ true! !!Point methodsFor: 'geometry' stamp: 'laza 1/5/2000 11:50'!to: end sideOf: otherPoint 	"Returns #left, #right, #center if the otherPoint lies to the left, right or on the line given by the vector from self to end"	^ end - self sideOf: otherPoint - self! !!Point methodsFor: 'geometry' stamp: 'laza 1/17/2000 15:47'!triangleArea: b with: c	"Returns twice the area of the oriented triangle (a, b, c), i.e., the   	area is positive if the triangle is oriented counterclockwise"	^ b x - self x * (c y - self y) - (b y - self y * (c x - self x))! !!Point methodsFor: 'interpolating' stamp: 'jsp 3/22/1999 16:31'!interpolateTo: end at: amountDone	"Interpolate between the instance and end after the specified amount has been done (0 - 1)."	^ self + ((end - self) * amountDone).! !!Point methodsFor: 'point functions' stamp: 'bf 5/29/2012 17:25'!area	^ x * y! !!Point methodsFor: 'point functions' stamp: 'FBS 1/5/2004 13:08'!bearingToPoint: anotherPoint    "Return the bearing, in degrees, from the receiver to anotherPoint.     Adapted from Playground, where the ultimate provenance of the algorithm was a wild earlier method of Jay Fenton's which I never checked carefully, but the thing has always seemed to work"    | deltaX deltaY  |    deltaX := anotherPoint x -  x.    deltaY := anotherPoint y - y.    deltaX abs < 0.001        ifTrue:            [^ deltaY > 0 ifTrue: [180] ifFalse: [0]].    ^ ((deltaX >= 0 ifTrue: [90] ifFalse: [270])            - ((deltaY / deltaX) arcTan negated radiansToDegrees)) rounded! !!Point methodsFor: 'point functions' stamp: 'ar 10/30/1998 03:05'!crossProduct: aPoint 	"Answer a number that is the cross product of the receiver and the 	argument, aPoint."	^ (x * aPoint y) - (y * aPoint x)! !!Point methodsFor: 'point functions' stamp: 'spfa 11/6/2004 16:01'!dist: aPoint 	"Answer the distance between aPoint and the receiver."	| dx dy |	dx := aPoint x - x.	dy := aPoint y - y.	^ ((dx * dx) + (dy * dy)) sqrt! !!Point methodsFor: 'point functions' stamp: 'di 9/11/1998 16:22'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	^ (x * aPoint x) + (y * aPoint y)! !!Point methodsFor: 'point functions' stamp: 'nice 12/29/2010 15:07'!eightNeighbors	^ (Array with: self + (1 @ 0)		with: self + (1 @ 1)		with: self + (0 @ 1)		with: self + (-1 @ 1)) ,	(Array with: self + (-1 @ 0)		with: self + (-1 @ -1)		with: self + (0 @ -1)		with: self + (1 @ -1))! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 16:08'!flipBy: direction centerAt: c	"Answer a Point which is flipped according to the direction about the point c.	Direction must be #vertical or #horizontal."	direction == #vertical ifTrue: [^ x @ (c y * 2 - y)].	direction == #horizontal ifTrue: [^ (c x * 2 - x) @ y].	self error: 'unrecognizable direction'! !!Point methodsFor: 'point functions' stamp: 'wiz 8/6/2007 20:33'!fourDirections	"Return vertices for a square centered at 0 asPoint with the receiver as first corner.	Returns the four rotation of the reciever in counter clockwise order with the reciever 	appearing last. "	^ Array with: self leftRotated			with: self negated			with: self rightRotated			with: self 		! !!Point methodsFor: 'point functions' stamp: 'nice 12/29/2010 14:57'!fourNeighbors	^ Array with: self + (1 @ 0)		with: self + (0 @ 1)		with: self + (-1 @ 0)		with: self + (0 @ -1)! !!Point methodsFor: 'point functions'!grid: aPoint 	"Answer a Point to the nearest rounded grid modules specified by aPoint."	| newX newY |	newX := x + (aPoint x // 2) truncateTo: aPoint x.	newY := y + (aPoint y // 2) truncateTo: aPoint y.	^newX @ newY! !!Point methodsFor: 'point functions' stamp: 'ar 5/22/2001 23:46'!insideTriangle: p1 with: p2 with: p3	"Return true if the receiver is within the triangle defined by the three coordinates.	Note: This method computes the barycentric coordinates for the receiver and tests those coordinates."	| p0 b0 b1 b2 b3 |	p0 := self.	b0 := ((p2 x - p1 x) * (p3 y - p1 y)) - ((p3 x - p1 x) * (p2 y - p1 y)).	b0 isZero ifTrue:[^false]. "degenerate"	b0 := 1.0 / b0.	b1 := (((p2 x - p0 x) * (p3 y - p0 y)) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.	b2 := (((p3 x - p0 x) * (p1 y - p0 y)) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.	b3 := (((p1 x - p0 x) * (p2 y - p0 y)) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.	b1 < 0.0 ifTrue:[^false].	b2 < 0.0 ifTrue:[^false].	b3 < 0.0 ifTrue:[^false].	^true! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 03:32'!leftRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #left centerAt: 0 asPoint .Compare to transposed and normal. "	^y  @x negated! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:37'!nearestPointAlongLineFrom: p1 to: p2	"Note this will give points beyond the endpoints.	Streamlined by Gerardo Richarte 11/3/97"	| x21 y21 t x1 y1 |	p1 x = p2 x ifTrue: [^ p1 x @ y].	p1 y = p2 y ifTrue: [^ x @ p1 y].	x1 := p1 x asFloat.	y1 := p1 y asFloat.	x21 := p2 x asFloat - x1.	y21 := p2 y asFloat - y1.	t := ((y asFloat - y1 / x21) + (x asFloat - x1 / y21))			/ ((x21 / y21) + (y21 / x21)).	^ (x1 + (t * x21)) @ (y1 + (t * y21))"	| old new |	Pen new place: 200@100; goto: (old := 500@300).	Display reverse: (old extent: 10@10).	[Sensor anyButtonPressed] whileFalse:		[(new := (Sensor cursorPoint nearestPointAlongLineFrom: 200@100 to: 500@300) )			= old ifFalse:				[Display reverse: (old extent: 10@10).				Display reverse: ((old := new) extent: 10@10)]]"! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:40'!nearestPointOnLineFrom: p1 to: p2	"This will not give points beyond the endpoints"	^ (self nearestPointAlongLineFrom: p1 to: p2)		adhereTo: (p1 rect: p2)! !!Point methodsFor: 'point functions' stamp: 'wiz 7/28/2007 20:50'!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise.	For the zero point return a normal of  -1@0   ."	| n d |		n := y negated @ x.	(d := (n x * n x + (n y * n y))) = 0 ifTrue: [ ^  -1 @0  ] .	^n / d sqrt! !!Point methodsFor: 'point functions' stamp: 'ar 8/26/2001 22:15'!normalized	"Optimized for speed -- ar 8/26/2001"	| r |	r := ((x*x) + (y * y)) sqrt.	^(x / r) @ (y / r)! !!Point methodsFor: 'point functions' stamp: 'laza 12/13/1999 11:43'!octantOf: otherPoint 	"Return 1..8 indicating relative direction to otherPoint.  	1=ESE, 2=SSE, ... etc. clockwise to 8=ENE"	"[Sensor anyButtonPressed] whileFalse: [(Display boundingBox center 	octantOf: Sensor cursorPoint) printString displayAt: 0@0]"	| quad moreHoriz |	(x = otherPoint x and: [y > otherPoint y])		ifTrue: [^ 6].	"special case"	(y = otherPoint y and: [x < otherPoint x])		ifTrue: [^ 8].	quad := self quadrantOf: otherPoint.	moreHoriz := (x - otherPoint x) abs >= (y - otherPoint y) abs.	(quad even eqv: moreHoriz)		ifTrue: [^ quad * 2]		ifFalse: [^ quad * 2 - 1]! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:12'!onLineFrom: p1 to: p2	^ self onLineFrom: p1 to: p2 within: 2! !!Point methodsFor: 'point functions' stamp: 'jm 2/24/98 08:34'!onLineFrom: p1 to: p2 within: epsilon	"Answer true if the receiver lies on the given line segment between p1 and p2 within a small epsilon."	"is this point within the box spanning p1 and p2 expanded by epsilon? (optimized)"	p1 x < p2 x		ifTrue: [			((x < (p1 x - epsilon)) or: [x > (p2 x + epsilon)]) ifTrue: [^ false]]		ifFalse: [			((x < (p2 x - epsilon)) or: [x > (p1 x + epsilon)]) ifTrue: [^ false]].	p1 y < p2 y		ifTrue: [			((y < (p1 y - epsilon)) or: [y > (p2 y + epsilon)]) ifTrue: [^ false]]		ifFalse: [			((y < (p2 y - epsilon)) or: [y > (p1 y + epsilon)]) ifTrue: [^ false]].	"it's in the box; is it on the line?"	^ (self dist: (self nearestPointAlongLineFrom: p1 to: p2)) <= epsilon! !!Point methodsFor: 'point functions' stamp: '6/9/97 14:51 di'!quadrantOf: otherPoint	"Return 1..4 indicating relative direction to otherPoint.	1 is downRight, 2=downLeft, 3=upLeft, 4=upRight"	^ x <= otherPoint x		ifTrue: [y < otherPoint y ifTrue: [1] ifFalse: [4]]		ifFalse: [y <= otherPoint y ifTrue: [2] ifFalse: [3]]"[Sensor anyButtonPressed] whileFalse:	[(Display boundingBox center quadrantOf: Sensor cursorPoint) printString displayAt: 0@0]"! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 02:33'!rightRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #right centerAt: 0 asPoint .Compare to transposed and normal. "	^y negated @x! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 15:12'!rotateBy: direction centerAt: c	"Answer a Point which is rotated according to direction, about the point c.	Direction must be one of #right (CW), #left (CCW) or #pi (180 degrees)."	| offset |	offset := self - c.	direction == #right ifTrue: [^ (offset y negated @ offset x) + c].	direction == #left ifTrue: [^ (offset y @ offset x negated) + c].	direction == #pi ifTrue: [^ c - offset].	self error: 'unrecognizable direction'! !!Point methodsFor: 'point functions' stamp: 'wiz 8/1/2007 16:53'!sign^ (x sign @ y sign) .! !!Point methodsFor: 'point functions' stamp: 'ar 4/18/1999 05:17'!sortsBefore: otherPoint	"Return true if the receiver sorts before the other point"	^y = otherPoint y		ifTrue:[x <= otherPoint x]		ifFalse:[y <= otherPoint y]! !!Point methodsFor: 'point functions' stamp: 'ar 5/23/2001 21:29'!squaredDistanceTo: aPoint	"Answer the distance between aPoint and the receiver."	| delta |	delta := aPoint - self.	^delta dotProduct: delta! !!Point methodsFor: 'point functions' stamp: 'ar 11/12/1998 01:44'!transposed	^y@x! !!Point methodsFor: 'polar coordinates' stamp: 'di 6/12/97 12:18'!degrees	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^ 90.0]				ifFalse: [^ 270.0]]		ifFalse: 			[tan := y asFloat / x asFloat.			theta := tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^ theta radiansToDegrees]						ifFalse: [^ 360.0 + theta radiansToDegrees]]				ifFalse: [^ 180.0 + theta radiansToDegrees]]! !!Point methodsFor: 'polar coordinates'!r	"Answer the receiver's radius in polar coordinate system."	^(self dotProduct: self) sqrt! !!Point methodsFor: 'polar coordinates' stamp: 'nice 10/12/2007 23:30'!theta	"Answer the angle the receiver makes with origin in radians. right is 0; 	down is 90. 	Corrected the constants from single precision to 64 Bit precision 	and changed the sends in case of overflow to constants HK 2005-07-23"	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^ 1.5707963267948966 "90.0 degreesToRadians"]				ifFalse: [^ 4.71238898038469 "270.0 degreesToRadians"]]		ifFalse: 			[tan := y asFloat / x asFloat.			theta := tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^theta]						ifFalse: [^"360.0 degreesToRadians" 6.283185307179586 + theta]]				ifFalse: [^"180.0 degreesToRadians" 3.141592653589793 + theta]]! !!Point methodsFor: 'printing' stamp: 'eem 2/21/2013 10:18'!printOn: aStream 	"The receiver prints on aStream in terms of infix notation."	x printOn: aStream.	aStream nextPut: $@.	(y isNumber and: [y negative]) ifTrue:		"Avoid ambiguous @- construct"		[aStream space].	y printOn: aStream! !!Point methodsFor: 'printing' stamp: 'ar 7/8/2006 19:15'!storeOn: aStream 	"x@y printed form is good for storing too"	aStream nextPut: $(.	self printOn: aStream.	aStream nextPut: $).! !!Point methodsFor: 'testing' stamp: 'wiz 1/11/2006 18:32'!isIntegerPoint^ x isInteger and: [ y isInteger ] ! !!Point methodsFor: 'testing' stamp: 'di 11/6/1998 07:45'!isPoint	^ true! !!Point methodsFor: 'testing' stamp: 'ar 10/29/2000 19:02'!isZero	^x isZero and:[y isZero]! !!Point methodsFor: 'transforming' stamp: 'di 4/30/1998 11:16'!adhereTo: aRectangle	"If the receiver lies outside aRectangle, return the nearest point on the boundary of the rectangle, otherwise return self."	(aRectangle containsPoint: self) ifTrue: [^ self].	^ ((x max: aRectangle left) min: aRectangle right)		@ ((y max: aRectangle top) min: aRectangle bottom)! !!Point methodsFor: 'transforming' stamp: 'ar 8/26/2001 22:14'!negated	"Answer a point whose x and y coordinates are the negatives of those of the receiver.  6/6/96 sw"	"Optimized for speed -- ar 8/26/2001"	^ (0 - x) @ (0 - y)! !!Point methodsFor: 'transforming'!rotateBy: angle about: center	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretateion of angle."	| p r theta |	p := self - center.	r := p r.	theta := angle asFloat - p theta.	^ (center x asFloat + (r * theta cos)) @	  (center y asFloat - (r * theta sin))! !!Point methodsFor: 'transforming'!scaleBy: factor 	"Answer a Point scaled by factor (an instance of Point)."	^(factor x * x) @ (factor y * y)! !!Point methodsFor: 'transforming' stamp: 'di 12/4/97 14:34'!scaleFrom: rect1 to: rect2	"Produce a point stretched according to the stretch from rect1 to rect2"	^ rect2 topLeft + (((x-rect1 left) * rect2 width // rect1 width)					@ ((y-rect1 top) * rect2 height // rect1 height))! !!Point methodsFor: 'transforming' stamp: 'ar 12/10/2009 00:18'!transformedBy: aTransform	"Point transform double dispatch"	^aTransform transformPoint: self! !!Point methodsFor: 'transforming'!translateBy: delta 	"Answer a Point translated by delta (an instance of Point)."	^(delta x + x) @ (delta y + y)! !!Point methodsFor: 'truncation and round off' stamp: 'nice 2/5/2006 16:43'!ceiling	"Answer a Point that is the receiver's x and y ceiling. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x ceiling @ y ceiling! !!Point methodsFor: 'truncation and round off' stamp: 'nice 2/5/2006 16:43'!floor	"Answer a Point that is the receiver's x and y floor. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x floor @ y floor! !!Point methodsFor: 'truncation and round off' stamp: 'nice 2/5/2006 16:42'!roundDownTo: grid	"Answer a Point that is the receiver's x and y rounded to grid x and 	grid y by lower value (toward negative infinity)."		| gridPoint |	gridPoint := grid asPoint.	^(x roundDownTo: gridPoint x) @ (y roundDownTo: gridPoint y)! !!Point methodsFor: 'truncation and round off' stamp: 'nice 2/5/2006 16:41'!roundUpTo: grid	"Answer a Point that is the receiver's x and y rounded to grid x and 	grid y by upper value (toward infinity)."		| gridPoint |	gridPoint := grid asPoint.	^(x roundUpTo: gridPoint x) @ (y roundUpTo: gridPoint y)! !!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!rounded	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x rounded @ y rounded! !!Point methodsFor: 'truncation and round off' stamp: 'nice 2/5/2006 16:35'!roundTo: grid	"Answer a Point that is the receiver's x and y rounded to grid x and 	grid y."		| gridPoint |	gridPoint := grid asPoint.	^(x roundTo: gridPoint x) @ (y roundTo: gridPoint y)! !!Point methodsFor: 'truncation and round off'!truncateTo: grid	"Answer a Point that is the receiver's x and y truncated to grid x and 	grid y."	| gridPoint |	gridPoint := grid asPoint.	^(x truncateTo: gridPoint x) @ (y truncateTo: gridPoint y)! !!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x truncated @ y truncated! !!Point methodsFor: 'private' stamp: 'ar 4/4/1999 00:40'!bitShiftPoint: bits	x := x bitShift: bits.	y := y bitShift: bits.! !!Point methodsFor: 'private' stamp: 'tk 10/4/2001 16:16'!setR: rho degrees: degrees 	| radians |	radians := degrees asFloat degreesToRadians.	x := rho asFloat * radians cos.	y := rho asFloat * radians sin.! !!Point methodsFor: 'private' stamp: 'sw 3/21/2000 13:24'!setX: xValue setY: yValue	x := xValue.	y := yValue! !!Point methodsFor: '*Etoys-tiles' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Point! !!Point methodsFor: 'extent functions' stamp: 'mt 7/13/2016 12:08'!guarded	"Return a positive nonzero extent."	^ self max: 1@1! !!Point methodsFor: 'extent functions' stamp: 'mt 7/13/2016 12:09'!scaleTo: anExtent	"Return a Point scalefactor for shrinking a thumbnail of the receiver's extent to fit within anExtent. self and anExtent are expected to have positive nonZero x and y."	|  factor  sX sY | 	factor :=  3.0  reciprocal .	sX := anExtent x / self  x asFloat  .	sY :=  anExtent y / self  y asFloat  .	sX = sY ifTrue: [ ^ sX @ sY ] . "Same aspect ratio"	^ sX < sY ifTrue: [   sX @ (sX max: sY * factor) ] 		ifFalse: [  (sY max: sX * factor ) @ sY  ] ! !!Point methodsFor: '*Etoys-Squeakland-arithmetic' stamp: 'bf 7/25/2010 14:40'!grouped	"Sent as a pseudo-function for parenthesizing in tile scripts."	^ self! !!Point methodsFor: '*Etoys-Squeakland-comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!Point methodsFor: 'converting to rectangle' stamp: 'mt 12/10/2018 14:08'!center: aPoint 	"Answer a Rectangle whose extent is the receiver and whose center is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle center: aPoint extent: self! !!Point methodsFor: 'converting to rectangle'!corner: aPoint 	"Answer a Rectangle whose origin is the receiver and whose corner is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: self corner: aPoint! !!Point methodsFor: 'converting to rectangle'!extent: aPoint 	"Answer a Rectangle whose origin is the receiver and whose extent is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: self extent: aPoint! !!Point methodsFor: 'converting to rectangle' stamp: 'mt 12/10/2018 14:07'!origin: aPoint 	"Answer a Rectangle whose extent is the receiver and whose origin is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: aPoint extent: self! !!Point methodsFor: 'converting to rectangle' stamp: 'di 12/3/97 19:00'!rect: aPoint 	"Answer a Rectangle that encompasses the receiver and aPoint.	This is the most general infix way to create a rectangle."	^ Rectangle 		origin: (self min: aPoint)		corner: (self max: aPoint)! !!Point methodsFor: '*MorphicExtras-Postscript Canvases'!encodePostscriptOn:aStream 	aStream writePoint:self.! !!Point methodsFor: '*nebraska-Morphic-Remote' stamp: 'RAA 7/31/2000 17:27'!encodeForRemoteCanvas	| encoded |	CanvasEncoder at: 3 count:  1.	encoded := String new: 8.	encoded putInteger32: x asInteger at: 1.	encoded putInteger32: y asInteger at: 5.	^encoded! !!Point methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!fromSton: stonReader	stonReader parseListDo: [ :each :index |		index = 1 ifTrue: [ x := each ].		index = 2 ifTrue: [ y := each ] ]! !!Point methodsFor: '*ston-core' stamp: '5/7/2020 21:03:38'!stonOn: stonWriter	stonWriter writeObject: self streamShortList: [ :array |		array add: x; add: y ]! !!Point class methodsFor: 'instance creation' stamp: 'sw 9/20/97 15:34'!fromUser	Sensor waitNoButton.	Cursor crossHair show.	Sensor waitButton.	Cursor normal show.	^ Sensor cursorPoint"Point fromUser"! !!Point class methodsFor: 'instance creation' stamp: 'wiz 5/4/2006 00:04'!fromUserWithCursor: aCursor	Sensor waitNoButton.	aCursor showWhile:[Sensor waitButton].	^ Sensor cursorPoint"Point fromUserWithCursor: Cursor target"! !!Point class methodsFor: 'instance creation' stamp: 'md 12/2/2004 23:44'!r: rho degrees: degrees	"Answer an instance of me with polar coordinates rho and theta."	^self basicNew setR: rho degrees: degrees! !!Point class methodsFor: 'instance creation' stamp: 'jrd 5/26/2010 12:31'!u: xInteger v: yInteger 	"Answer an instance of me with coordinates xInteger and yInteger."	^self new setX: xInteger setY: yInteger! !!Point class methodsFor: 'instance creation' stamp: 'md 12/2/2004 23:44'!x: xInteger y: yInteger 	"Answer an instance of me with coordinates xInteger and yInteger."	^self basicNew setX: xInteger setY: yInteger! !!Point class methodsFor: '*Etoys-Squeakland-instance creation' stamp: 'sw 2/5/2012 23:55'!readEToyPointFrom: aString	"Answer a point as described in the string"	| atPos xString yString |	atPos := aString indexOf: $@ ifAbsent: [nil].		xString := atPos		ifNil:			 [aString]		ifNotNil:			[aString copyFrom: 1 to: (atPos - 1)].	yString := atPos		ifNil:			[aString]		ifNotNil:			[aString copyFrom: (atPos + 1) to: aString size].	^ (Number readEToyNumberFrom: xString) @ (Number readEToyNumberFrom: yString)"Point readEToyPointFrom:  '2.345 @ -23.49'"! !